/**
 * articleController.js
 * Saves blog posts generated by the Python AI service.
 * Handles: Supabase save, image upload, credit deduction, push notification.
 */

import { createClient } from '@supabase/supabase-js';
import axios from 'axios';
import CreditLedgerService from '../services/creditLedgerService.js';
import { sendPushNotification } from '../services/pushService.js';
import { supabaseAdmin } from '../config/supabaseClient.js';

const ADMIN_ID = '0d396440-7d07-407c-89da-9cb93e353347';
const PYTHON_API_URL = process.env.PYTHON_API_URL || 'http://localhost:8000';

// Determine table: admins default to company_articles unless explicitly overridden
const getTableName = (userId, targetTable) => {
    if (userId === ADMIN_ID) {
        return targetTable === 'articles' ? 'articles' : 'company_articles';
    }
    return 'articles';
};

// Slug generator
const generateSlug = (text) =>
    text.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');

// Upload image URL to Supabase Storage and return public URL
const uploadImageToSupabase = async (imageUrl) => {
    if (!imageUrl) return null;
    try {
        const response = await axios.get(imageUrl, { responseType: 'arraybuffer', timeout: 15000 });
        const buffer = Buffer.from(response.data);
        const filename = `blog-${Date.now()}.png`;
        const { data, error } = await supabaseAdmin.storage
            .from('blog-images')
            .upload(filename, buffer, { contentType: 'image/png', upsert: true });
        if (error) throw error;
        const { data: urlData } = supabaseAdmin.storage.from('blog-images').getPublicUrl(filename);
        return urlData.publicUrl;
    } catch (e) {
        console.error('Image upload failed:', e.message);
        return imageUrl; // fallback: use the raw URL
    }
};

// ─────────────────────────────────────────────────────────────────────────────
// POST /api/articles/generate
// Calls Python to generate, then saves result to Supabase
// ─────────────────────────────────────────────────────────────────────────────
export const generateArticle = async (req, res) => {
    const userId = req.user.id;
    const token = req.token;
    const {
        topic, industry, keywords, language, style, length, audience,
        image_option, custom_image_url, wp_url,
        // Saving-specific fields (not sent to Python)
        author_name, author_bio, author_profile_id, author_details,
        category = 'Technology', tags = [], is_published = false,
        custom_slug, target_table,
    } = req.body;

    const tableName = getTableName(userId, target_table);

    // ── 1. Credit pre-flight ──────────────────────────────────────────────────
    if (userId !== ADMIN_ID) {
        try {
            const check = await CreditLedgerService.validateCredits(userId, 'blog', 1);
            if (!check.hasEnough) {
                return res.status(402).json({
                    success: false,
                    error: 'Insufficient credits',
                    required: check.creditsNeeded,
                    balance: check.currentBalance,
                });
            }
        } catch (e) {
            console.error('Credit check failed:', e);
        }
    }

    // ── 2. Call Python generation service ─────────────────────────────────────
    let genData;
    try {
        const genRes = await axios.post(
            `${PYTHON_API_URL}/api/blog/generate`,
            { topic, industry, keywords, language, style, length, audience, image_option, custom_image_url, wp_url },
            { headers: { Authorization: req.headers.authorization }, timeout: 120000 }
        );
        genData = genRes.data;
        if (!genData.success) throw new Error(genData.error || 'Generation failed');
    } catch (e) {
        console.error('Python generation error:', e.message);
        return res.status(500).json({ success: false, error: `Generation failed: ${e.message}` });
    }

    const { article: blogHtml, markdown: blogText, seoTitle, imageUrl: rawImageUrl, wordCount, plagiarismCheck, topic: finalTopic, keywords: finalKeywords } = genData;

    // ── 3. Upload image to Supabase Storage ───────────────────────────────────
    const imageUrl = await uploadImageToSupabase(rawImageUrl);

    // ── 4. Build slug ─────────────────────────────────────────────────────────
    const slug = custom_slug
        ? generateSlug(custom_slug)
        : `${generateSlug(seoTitle || finalTopic)}-${Math.floor(Math.random() * 1000)}`;

    const readTime = Math.ceil(wordCount / 200);

    // ── 5. Save to Supabase ───────────────────────────────────────────────────
    const scoped = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, {
        global: { headers: { Authorization: `Bearer ${token}` } },
        auth: { persistSession: false },
    });

    const payload = {
        user_id: userId,
        topic: finalTopic,
        keywords: finalKeywords,
        content: blogHtml,
        seo_title: seoTitle,
        seo_description: `Read about ${finalTopic}. ${wordCount} words.`,
        image_url: imageUrl,
        featured_image: imageUrl,
        word_count: wordCount,
        plagiarism_check: plagiarismCheck,
        language: language || 'English',
        style: style || 'Professional',
        slug,
        category,
        tags,
        author_name: author_name || 'AI Agent',
        author_bio: author_bio || 'Generated by AI',
        author_profile_id: author_profile_id || null,
        author_details: author_details || null,
        is_published,
        publish_date: is_published ? new Date().toISOString() : null,
        estimated_read_time: readTime,
        social_share_enabled: true,
        comments_enabled: true,
    };

    const { data: savedArticle, error: saveError } = await (tableName === 'company_articles' ? supabaseAdmin : scoped)
        .from(tableName)
        .insert(payload)
        .select()
        .single();

    if (saveError) {
        console.error('Supabase save error:', saveError);
        return res.status(500).json({ success: false, error: 'Failed to save article' });
    }

    // ── 6. Deduct credits ─────────────────────────────────────────────────────
    let ledgerResult = {};
    try {
        ledgerResult = await CreditLedgerService.deductCreditsWithLedger({
            userId,
            agentType: 'blog',
            referenceId: savedArticle.id,
            referenceTable: tableName,
            usageQuantity: 1,
            metadata: { topic: finalTopic, language, style, model: 'sonar-pro', category, actual_word_count: wordCount },
        });
    } catch (e) {
        console.error('⚠️ Credit deduction failed (article saved):', e);
    }

    // ── 7. Push notification (non-blocking) ───────────────────────────────────
    if (is_published) {
        sendPushNotification({
            title: `New Article: ${finalTopic}`,
            body: `Check out our latest post on "${finalTopic}"!`,
            image: imageUrl,
            data: { slug, url: `/blogs/${slug}` },
        }).catch(e => console.error('Push failed:', e));
    }

    return res.json({
        success: true,
        article: blogHtml,
        seoTitle,
        imageUrl,
        wordCount,
        plagiarismCheck,
        id: savedArticle.id,
        slug: savedArticle.slug,
        topic: finalTopic,
        creditsUsed: ledgerResult.credits_deducted,
        newBalance: ledgerResult.new_balance,
    });
};

// ─────────────────────────────────────────────────────────────────────────────
// POST /api/blog/posts  — create article directly (not via AI generation)
// ─────────────────────────────────────────────────────────────────────────────
export const createArticle = async (req, res) => {
    const userId = req.user.id;
    const token = req.token;
    const { target_table, is_company_blog, notification_settings, title, ...articleData } = req.body;
    const tableName = getTableName(userId, target_table);

    // Add user_id if not present
    articleData.user_id = articleData.user_id || userId;

    // Map frontend 'title' to database 'topic'
    if (title) articleData.topic = title;

    // Generate slug if missing
    if (!articleData.slug && (articleData.seo_title || articleData.topic)) {
        articleData.slug = `${generateSlug(articleData.seo_title || articleData.topic)}-${Math.floor(Math.random() * 1000)}`;
    }

    const sb = tableName === 'company_articles' ? supabaseAdmin :
        createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, { global: { headers: { Authorization: `Bearer ${token}` } }, auth: { persistSession: false } });

    const { data, error } = await sb.from(tableName).insert(articleData).select().single();
    if (error) {
        console.error('Create article error:', error);
        return res.status(500).json({ success: false, error: error.message });
    }

    res.json({ success: true, post: data });
};

// ─────────────────────────────────────────────────────────────────────────────
// CRUD — /api/blog/posts/:id  (list, get, update, delete)
// ─────────────────────────────────────────────────────────────────────────────

export const listArticles = async (req, res) => {
    const userId = req.user.id;
    const token = req.token;
    const { page = 1, limit = 10, target_table } = req.query;
    const tableName = getTableName(userId, target_table);
    const offset = (parseInt(page) - 1) * parseInt(limit);

    const sb = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, {
        global: { headers: { Authorization: `Bearer ${token}` } },
        auth: { persistSession: false },
    });

    const { data, error, count } = await (tableName === 'company_articles' ? supabaseAdmin : sb)
        .from(tableName)
        .select('*', { count: 'exact' })
        .order('created_at', { ascending: false })
        .range(offset, offset + parseInt(limit) - 1);

    if (error) return res.status(500).json({ success: false, error: error.message });
    res.json({ success: true, posts: data, total: count, page: parseInt(page) });
};

export const getArticle = async (req, res) => {
    const userId = req.user.id;
    const token = req.token;
    const { id } = req.params;
    const { target_table } = req.query;
    const tableName = getTableName(userId, target_table);

    const sb = tableName === 'company_articles' ? supabaseAdmin :
        createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, { global: { headers: { Authorization: `Bearer ${token}` } }, auth: { persistSession: false } });

    const { data, error } = await sb.from(tableName).select('*').eq('id', id).single();
    if (error || !data) return res.status(404).json({ success: false, error: 'Not found' });
    res.json({ success: true, post: data });
};

export const updateArticle = async (req, res) => {
    const userId = req.user.id;
    const token = req.token;
    const { id } = req.params;
    const { target_table, is_company_blog, notification_settings, title, ...updates } = req.body;
    const tableName = getTableName(userId, target_table);

    // Map frontend 'title' field to database 'topic' column
    if (title) updates.topic = title;

    const sb = tableName === 'company_articles' ? supabaseAdmin :
        createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, { global: { headers: { Authorization: `Bearer ${token}` } }, auth: { persistSession: false } });

    const { data, error } = await sb.from(tableName).update(updates).eq('id', id).select().single();
    if (error) {
        console.error('Update article error:', error);
        return res.status(500).json({ success: false, error: error.message });
    }

    // Send push if publishing
    if (updates.is_published && data) {
        const notif = updates.notification_settings || {};
        sendPushNotification({
            title: notif.title || `New Post: ${data.topic || 'Fresh Content'}`,
            body: notif.body || data.seo_description || 'Check out our latest update!',
            image: notif.image || data.featured_image,
            data: { slug: data.slug, url: `/blogs/${data.slug}` },
        }).catch(() => { });
    }

    res.json({ success: true, post: data });
};

export const deleteArticle = async (req, res) => {
    const userId = req.user.id;
    const token = req.token;
    const { id } = req.params;
    const { target_table } = req.query;
    const tableName = getTableName(userId, target_table);

    const sb = tableName === 'company_articles' ? supabaseAdmin :
        createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY, { global: { headers: { Authorization: `Bearer ${token}` } }, auth: { persistSession: false } });

    const { error } = await sb.from(tableName).delete().eq('id', id);
    if (error) return res.status(500).json({ success: false, error: error.message });
    res.json({ success: true, message: 'Deleted' });
};

// Public endpoints (no auth needed)
export const publicListBlogs = async (req, res) => {
    const { page = 1, limit = 10, sort = 'created_at', order = 'desc' } = req.query;
    const offset = (parseInt(page) - 1) * parseInt(limit);

    const { data, error, count } = await supabaseAdmin
        .from('company_articles')
        .select('id, topic, seo_title, seo_description, image_url, featured_image, slug, category, tags, author_name, publish_date, created_at, estimated_read_time, word_count', { count: 'exact' })
        .eq('is_published', true)
        .order(sort, { ascending: order === 'asc' })
        .range(offset, offset + parseInt(limit) - 1);

    if (error) return res.status(500).json({ success: false, error: error.message });
    const totalPages = Math.ceil(count / parseInt(limit));
    res.json({
        success: true, articles: data,
        pagination: { currentPage: parseInt(page), totalPages, hasNextPage: parseInt(page) < totalPages, hasPrevPage: parseInt(page) > 1, total: count }
    });
};

export const publicGetBlog = async (req, res) => {
    const { identifier } = req.params;
    const isUuid = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(identifier);

    const query = supabaseAdmin.from('company_articles').select('*').eq('is_published', true);
    const { data, error } = await (isUuid ? query.eq('id', identifier) : query.eq('slug', identifier)).single();

    if (error || !data) return res.status(404).json({ success: false, error: 'Article not found' });
    res.json({ success: true, article: data });
};
